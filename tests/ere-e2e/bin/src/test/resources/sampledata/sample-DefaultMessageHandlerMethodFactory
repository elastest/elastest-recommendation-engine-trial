{"_id": "sample-DefaultMessageHandlerMethodFactory","rawClasses": [{"DefaultMessageHandlerMethodFactoryTests.java": "/*\n * Copyright 2002-2017 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.messaging.handler.annotation.support;\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.ExpectedException;\nimport org.junit.rules.TestName;\n\nimport org.springframework.beans.factory.support.StaticListableBeanFactory;\nimport org.springframework.core.MethodParameter;\nimport org.springframework.core.convert.converter.Converter;\nimport org.springframework.core.convert.support.GenericConversionService;\nimport org.springframework.messaging.Message;\nimport org.springframework.messaging.converter.ByteArrayMessageConverter;\nimport org.springframework.messaging.converter.MessageConversionException;\nimport org.springframework.messaging.converter.MessageConverter;\nimport org.springframework.messaging.handler.annotation.Payload;\nimport org.springframework.messaging.handler.invocation.HandlerMethodArgumentResolver;\nimport org.springframework.messaging.handler.invocation.InvocableHandlerMethod;\nimport org.springframework.messaging.handler.invocation.MethodArgumentResolutionException;\nimport org.springframework.messaging.support.MessageBuilder;\nimport org.springframework.util.ReflectionUtils;\nimport org.springframework.validation.Errors;\nimport org.springframework.validation.Validator;\nimport org.springframework.validation.annotation.Validated;\n\nimport static org.junit.Assert.*;\n\n/**\n * @author Stephane Nicoll\n */\npublic class DefaultMessageHandlerMethodFactoryTests {\n\n\tprivate final SampleBean sample = new SampleBean();\n\n\t@Rule\n\tpublic final TestName name = new TestName();\n\n\t@Rule\n\tpublic final ExpectedException thrown = ExpectedException.none();\n\n\n\t@Test\n\tpublic void customConversion() throws Exception {\n\t\tDefaultMessageHandlerMethodFactory instance = createInstance();\n\t\tGenericConversionService conversionService = new GenericConversionService();\n\t\tconversionService.addConverter(SampleBean.class, String.class, new Converter<SampleBean, String>() {\n\t\t\t@Override\n\t\t\tpublic String convert(SampleBean source) {\n\t\t\t\treturn \"foo bar\";\n\t\t\t}\n\t\t});\n\t\tinstance.setConversionService(conversionService);\n\t\tinstance.afterPropertiesSet();\n\n\t\tInvocableHandlerMethod invocableHandlerMethod =\n\t\t\t\tcreateInvocableHandlerMethod(instance, \"simpleString\", String.class);\n\n\t\tinvocableHandlerMethod.invoke(MessageBuilder.withPayload(sample).build());\n\t\tassertMethodInvocation(sample, \"simpleString\");\n\t}\n\n\t@Test\n\tpublic void customConversionServiceFailure() throws Exception {\n\t\tDefaultMessageHandlerMethodFactory instance = createInstance();\n\t\tGenericConversionService conversionService = new GenericConversionService();\n\t\tassertFalse(\"conversion service should fail to convert payload\",\n\t\t\t\tconversionService.canConvert(Integer.class, String.class));\n\t\tinstance.setConversionService(conversionService);\n\t\tinstance.afterPropertiesSet();\n\n\t\tInvocableHandlerMethod invocableHandlerMethod =\n\t\t\t\tcreateInvocableHandlerMethod(instance, \"simpleString\", String.class);\n\n\t\tthrown.expect(MessageConversionException.class);\n\t\tinvocableHandlerMethod.invoke(MessageBuilder.withPayload(123).build());\n\t}\n\n\t@Test\n\tpublic void customMessageConverterFailure() throws Exception {\n\t\tDefaultMessageHandlerMethodFactory instance = createInstance();\n\t\tMessageConverter messageConverter = new ByteArrayMessageConverter();\n\t\tinstance.setMessageConverter(messageConverter);\n\t\tinstance.afterPropertiesSet();\n\n\t\tInvocableHandlerMethod invocableHandlerMethod =\n\t\t\t\tcreateInvocableHandlerMethod(instance, \"simpleString\", String.class);\n\n\t\tthrown.expect(MessageConversionException.class);\n\t\tinvocableHandlerMethod.invoke(MessageBuilder.withPayload(123).build());\n\t}\n\n\t@Test\n\tpublic void customArgumentResolver() throws Exception {\n\t\tDefaultMessageHandlerMethodFactory instance = createInstance();\n\t\tList<HandlerMethodArgumentResolver> customResolvers = new ArrayList<>();\n\t\tcustomResolvers.add(new CustomHandlerMethodArgumentResolver());\n\t\tinstance.setCustomArgumentResolvers(customResolvers);\n\t\tinstance.afterPropertiesSet();\n\n\t\tInvocableHandlerMethod invocableHandlerMethod =\n\t\t\t\tcreateInvocableHandlerMethod(instance, \"customArgumentResolver\", Locale.class);\n\n\t\tinvocableHandlerMethod.invoke(MessageBuilder.withPayload(123).build());\n\t\tassertMethodInvocation(sample, \"customArgumentResolver\");\n\t}\n\n\t@Test\n\tpublic void overrideArgumentResolvers() throws Exception {\n\t\tDefaultMessageHandlerMethodFactory instance = createInstance();\n\t\tList<HandlerMethodArgumentResolver> customResolvers = new ArrayList<>();\n\t\tcustomResolvers.add(new CustomHandlerMethodArgumentResolver());\n\t\tinstance.setArgumentResolvers(customResolvers);\n\t\tinstance.afterPropertiesSet();\n\n\t\tMessage<String> message = MessageBuilder.withPayload(\"sample\").build();\n\n\t\t// This will work as the local resolver is set\n\t\tInvocableHandlerMethod invocableHandlerMethod =\n\t\t\t\tcreateInvocableHandlerMethod(instance, \"customArgumentResolver\", Locale.class);\n\t\tinvocableHandlerMethod.invoke(message);\n\t\tassertMethodInvocation(sample, \"customArgumentResolver\");\n\n\t\t// This won't work as no resolver is known for the payload\n\t\tInvocableHandlerMethod invocableHandlerMethod2 =\n\t\t\t\tcreateInvocableHandlerMethod(instance, \"simpleString\", String.class);\n\n\t\tthrown.expect(MethodArgumentResolutionException.class);\n\t\tthrown.expectMessage(\"No suitable resolver for\");\n\t\tinvocableHandlerMethod2.invoke(message);\n\t}\n\n\t@Test\n\tpublic void noValidationByDefault() throws Exception {\n\t\tDefaultMessageHandlerMethodFactory instance = createInstance();\n\t\tinstance.afterPropertiesSet();\n\n\t\tInvocableHandlerMethod invocableHandlerMethod =\n\t\t\t\tcreateInvocableHandlerMethod(instance, \"payloadValidation\", String.class);\n\t\tinvocableHandlerMethod.invoke(MessageBuilder.withPayload(\"failure\").build());\n\t\tassertMethodInvocation(sample, \"payloadValidation\");\n\t}\n\n\t@Test\n\tpublic void customValidation() throws Exception {\n\t\tDefaultMessageHandlerMethodFactory instance = createInstance();\n\t\tinstance.setValidator(new Validator() {\n\t\t\t@Override\n\t\t\tpublic boolean supports(Class<?> clazz) {\n\t\t\t\treturn String.class.isAssignableFrom(clazz);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void validate(Object target, Errors errors) {\n\t\t\t\tString value = (String) target;\n\t\t\t\tif (\"failure\".equals(value)) {\n\t\t\t\t\terrors.reject(\"not a valid value\");\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tinstance.afterPropertiesSet();\n\n\t\tInvocableHandlerMethod invocableHandlerMethod =\n\t\t\t\tcreateInvocableHandlerMethod(instance, \"payloadValidation\", String.class);\n\t\tthrown.expect(MethodArgumentNotValidException.class);\n\t\tinvocableHandlerMethod.invoke(MessageBuilder.withPayload(\"failure\").build());\n\t}\n\n\n\tprivate void assertMethodInvocation(SampleBean bean, String methodName) {\n\t\tassertTrue(\"Method \" + methodName + \" should have been invoked\", bean.invocations.get(methodName));\n\t}\n\n\tprivate InvocableHandlerMethod createInvocableHandlerMethod(\n\t\t\tDefaultMessageHandlerMethodFactory factory, String methodName, Class<?>... parameterTypes) {\n\t\treturn factory.createInvocableHandlerMethod(sample, getListenerMethod(methodName, parameterTypes));\n\t}\n\n\tprivate DefaultMessageHandlerMethodFactory createInstance() {\n\t\tDefaultMessageHandlerMethodFactory factory = new DefaultMessageHandlerMethodFactory();\n\t\tfactory.setBeanFactory(new StaticListableBeanFactory());\n\t\treturn factory;\n\t}\n\n\tprivate Method getListenerMethod(String methodName, Class<?>... parameterTypes) {\n\t\tMethod method = ReflectionUtils.findMethod(SampleBean.class, methodName, parameterTypes);\n\t\tassertNotNull(\"no method found with name \" + methodName + \" and parameters \" + Arrays.toString(parameterTypes));\n\t\treturn method;\n\t}\n\n\n\tstatic class SampleBean {\n\n\t\tprivate final Map<String, Boolean> invocations = new HashMap<>();\n\n\t\tpublic void simpleString(String value) {\n\t\t\tinvocations.put(\"simpleString\", true);\n\t\t}\n\n\t\tpublic void payloadValidation(@Payload @Validated String value) {\n\t\t\tinvocations.put(\"payloadValidation\", true);\n\t\t}\n\n\t\tpublic void customArgumentResolver(Locale locale) {\n\t\t\tinvocations.put(\"customArgumentResolver\", true);\n\t\t\tassertEquals(\"Wrong value for locale\", Locale.getDefault(), locale);\n\t\t}\n\t}\n\n\n\tstatic class CustomHandlerMethodArgumentResolver implements HandlerMethodArgumentResolver {\n\n\t\t@Override\n\t\tpublic boolean supportsParameter(MethodParameter parameter) {\n\t\t\treturn parameter.getParameterType().isAssignableFrom(Locale.class);\n\t\t}\n\n\t\t@Override\n\t\tpublic Object resolveArgument(MethodParameter parameter, Message<?> message) throws Exception {\n\t\t\treturn Locale.getDefault();\n\t\t}\n\t}\n\n}\n"}], "storyName": "The default MessageHandlerMethodFactory implementation creating an InvocableHandlerMethod with the necessary HandlerMethodArgumentResolver instances to detect and process most of the use cases defined by MessageMapping", "shortDesc": " Extra method argument resolvers can be added to customize the method signature that can be handled. By default, the validation process redirects to a no-op implementation, see setValidator(Validator) to customize it. The ConversionService can be customized in a similar manner to tune how the message payload can be converted."}
